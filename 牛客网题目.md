

## 0交换排序

长度为n的数组乱序存放着0至n-1. 现在只能进行0与其他数的交换，完成以下函数

```java
public class Solution {
    /**
     * 交换数组里n和0的位置
     * 
     * @param array
     *            数组
     * @param len
     *            数组长度
     * @param n
     *            和0交换的数
     */
    // 不要修改以下函数内容
    public void swapWithZero(int[] array, int len, int n) {
        Main.SwapWithZero(array, len, n);
    }
    // 不要修改以上函数内容


    /**
     * 通过调用swapWithZero方法来排
     * 
     * @param array
     *            存储有[0,n)的数组
     * @param len
     *            数组长度
     */
    public void sort(int[] array, int len) {
        // 完成这个函数
        int[] pos = new int[len];
        for (int i = 0; i < len; i++) {
            pos[array[i]] = i;
        }
        while (0 != array[0]) {
            swapWithZero(array, len, pos[0]);
            int tmp = pos[0];
            pos[0] = pos[tmp];
            pos[tmp] = tmp;
        }
        int N = 1;
        while (N < len) {
            if (array[N] == N) {
                N++;
            } else {
                pos[0] = N;
                pos[array[N]] = 0;
                swapWithZero(array, len, array[N]);
                while (0 != array[0]) {
                    swapWithZero(array, len, pos[0]);
                    int tmp = pos[0];
                    pos[0] = pos[tmp];
                    pos[tmp] = tmp;
                }
            }
        }        
        
    }
}
```


##  构造回文


给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回文串最长呢？
输出需要删除的字符个数。

输入描述:

输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.
  


输出描述:

对于每组数据，输出一个整数，代表最少需要删除的字符个数。

```
输入例子:
abcda
google

输出例子:
2
2
```


- 思路:

提到回文串，自然要利用回文串的特点，想到将源字符串逆转后，“回文串”（不一定连续）相当于顺序没变
求原字符串和其反串的最大公共子序列（不是子串，因为可以不连续）的长度（使用动态规划很容易求得），然后用原字符串的长度减去这个**最大公共子串的长度**就得到了最小编辑长度。


```java
import java.util.*;

//Main
public class T {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String str = sc.nextLine();
            char[] s1 = str.toCharArray();
            char[] s2 = new char[s1.length];
            for (int i = s1.length - 1; i >= 0; i--) {
                s2[s1.length - i - 1] = s1[i];
            }
            System.out.println(s1);
            System.out.println(s2);
            int len = s1.length;
            int[][] P = new int[len][len];
            int flag = 0;
            for (int i = 0; i < len; i++) {
                if (1 == flag) {
                    P[0][i] = 1;
                    continue;
                }
                if (s2[0] == s1[i]) {
                    P[0][i] = 1;
                    flag = 1;
                }
            }
            flag = 0;
            for (int i = 0; i < len; i++) {
                if (1 == flag) {
                    P[i][0] = 1;
                    continue;
                }
                if (s1[0] == s2[i]) {
                    P[i][0] = 1;
                    flag = 1;
                }
            }
            for (int i = 1; i < len; i++) {
                for (int j = 1; j < len; j++) {
                    if (s1[j] == s2[i]) {    //注意 i,j要和前面的行列相对应
                        P[i][j] = P[i - 1][j - 1] + 1;
                    } else {
                        P[i][j] = Math.max(P[i - 1][j], P[i][j - 1]);
                    }
                }
            }

            for (int i = 0; i < len; i++) {
                for (int j = 0; j < len; j++) {
                    System.out.print(P[i][j] + " ");
                }
                System.out.println("");
            }
            System.out.println(len - P[len - 1][len - 1]);

        }
    }

}

```
